#!/usr/bin/env ruby
require 'gli'
require 'calculator'
begin # XXX: Remove this begin/rescue before distributing your app
require 'statbench'
require 'reportbuilder'
rescue LoadError
  STDERR.puts "In development, you need to use `bundle exec bin/statbench` to run your app"
  STDERR.puts "At install-time, RubyGems will make sure lib, etc. are in the load path"
  STDERR.puts "Feel free to remove this message from bin/statbench now"
  exit 64
end

include GLI::App

program_desc 'statistical analysis of web server benchmark results'

version Statbench::VERSION

#desc 'Describe some switch here'
#switch [:s,:switch]

#desc 'Describe some flag here'
#default_value 'the default'
#arg_name 'The name of the argument'
#flag [:f,:flagname]

desc 'Calculate summary statistics'
arg_name 'filename'
command :summarize do |c|
  c.desc 'Display summary statistics of a dataset'
  c.switch :boxplot
  
  #c.desc 'Describe a flag to summarize'
  #c.default_value 'default'
  #c.flag :f
  c.action do |global_options,options,args|

    # Your command logic here
    

   args.each do |filename|
       data = Array.new
      File.open("#{filename}", "r").each_line do |line|
        data << line.to_f
      end
      calc = Calculator.new
      @output = calc.summary_stats(data)

      puts "Summary statistics for #{filename}:"
      @output.each do |name,data|
        puts "\t #{name}: #{data}"
      end
      puts "\n"
    end

    # If you have any errors, just raise them
    # raise "that command made no sense"
  end
end


desc 'print outlier data points'
arg_name 'filename'
command :outliers do |c|
  c.desc 'Invert matching, to select non-outlier data points'
  c.switch [:v,:'invert-match']
  c.action do |global_options,options,args|
    data = Array.new
    ARGF.readlines.each do |line|
      data << line.to_f
    end
    calc = Calculator.new
    
    @output = calc.find_outliers(data) unless options[:v]
    @output = calc.trim(data) if options[:v]
    
    @output.each do |number|
      puts number
    end
  end
end


desc 'Convert multiple files to CSV'
arg_name 'filename1 filename2 [filename3 ...]'
command :join do |c|
  c.desc 'Join multiple individual files into a CSV'

  c.action do |global_options,options,args|
   series=1
   args.each do |filename|
     data = Array.new
     File.open("#{filename}", "r").each_line do |line|
       data << line.to_f
     end
      
     counter=1
     data.each do |loadtime|
       puts "#{series},#{counter},#{loadtime}"
       counter += 1
     end
     series += 1
    end
  end
end

desc 'Generate HTML summary report'
arg_name 'filename1 filename2 [filename3 ...]'
command :report do |c|
  c.desc 'Generate a summary HTML report of multiple data files'

  c.action do |global_options,options,args|
    @rb=ReportBuilder.new
    @rb.name = "Web Server Performance Data"
    @datasets=Hash.new  
    args.each do |filename|
      @datasets["#{filename}"] = Array.new.to_scale
      File.open("#{filename}", "r").each_line do |line|
        @datasets["#{filename}"].add(line.to_f)
      end
    end

    arr = []
    @datasets.each_key do |key|
    @datasets["#{key}"].name = "#{key}"
      arr << @datasets["#{key}"]
    end

    @datasets.each do |filename,data|
      @rb.add(Statsample::Graph::Histogram.new(data,{:name=>"Load time distribution of #{filename}",:bins=>10}))

      data_numbers=*(1..data.to_a.length)
      @rb.add(Statsample::Graph::Scatterplot.new(data_numbers.to_scale,data,{:name => "All datapoints in #{filename}"}))
    end

    @rb.add(Statsample::Graph::Boxplot.new(:vectors=>arr,:name=>"Box plot for data comparison",:height => 700))
    @rb.save_html('summary_report.html')
  end
  #rb.add(Statsample::Graph::Boxplot.new(:vectors=>datasets,:name=>"boxplot"))
  

end

pre do |global,command,options,args|
  # Pre logic here
  # Return true to proceed; false to abort and not call the
  # chosen command
  # Use skips_pre before a command to skip this block
  # on that command only
  true
end

post do |global,command,options,args|
  # Post logic here
  # Use skips_post before a command to skip this
  # block on that command only
end

on_error do |exception|
  # Error logic here
  # return false to skip default error handling
  true
end

exit run(ARGV)
